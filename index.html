
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silent Camera App</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem; /* Add some padding around the body for smaller screens */
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background */
            padding: 1.5rem;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            text-align: center;
            max-width: 90%;
            width: 600px;
        }
        video, canvas {
            display: block;
            width: 100%;
            max-width: 560px; /* Max width for video/canvas */
            height: auto;
            border-radius: 0.5rem; /* Rounded corners for media elements */
            margin: 0 auto 1.5rem auto; /* Center and add margin below */
            background-color: #000; /* Black background for video/canvas when no stream */
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        button {
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            color: #fff;
            border: none;
            background-color: #4a5568; /* Default button color */
            flex-grow: 1; /* Allow buttons to grow and fill space on smaller screens */
            min-width: 120px; /* Ensure buttons don't get too small */
        }
        button:hover {
            background-color: #616c82; /* Darker on hover */
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(1px);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .message {
            margin-top: 1rem;
            color: #f6ad55; /* Orange for messages/errors */
        }
        .download-links {
            margin-top: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }
        .download-links a {
            color: #63b3ed; /* Blue for links */
            text-decoration: none;
            font-weight: 500;
        }
        .download-links a:hover {
            text-decoration: underline;
        }

        /* Specific button colors */
        #startCameraButton { background-color: #48bb78; } /* Green */
        #startCameraButton:hover { background-color: #68d391; }

        #takePhotoButton { background-color: #3182ce; } /* Blue */
        #takePhotoButton:hover { background-color: #63b3ed; }

        #recordVideoButton { background-color: #ed8936; } /* Orange */
        #recordVideoButton:hover { background-color: #f6ad55; }

        #stopRecordingButton { background-color: #e53e3e; } /* Red */
        #stopRecordingButton:hover { background-color: #fc8181; }

        #startAutoPhotoButton { background-color: #9f7aea; } /* Purple */
        #startAutoPhotoButton:hover { background-color: #b794f4; }

        #stopAutoPhotoButton { background-color: #e53e3e; } /* Red */
        #stopAutoPhotoButton:hover { background-color: #fc8181; }

        .input-group {
            display: flex;
            flex-direction: column; /* Stack vertically by default on small screens */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        /* For small screens and up, make input group horizontal */
        @media (min-width: 640px) { /* Tailwind's 'sm' breakpoint */
            .input-group {
                flex-direction: row;
            }
        }
        .input-group label {
            white-space: nowrap;
        }
        .input-group input, .input-group select {
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            width: 100%; /* Make input full width on small screens */
            max-width: 120px; /* Limit width on larger screens */
        }
        .input-group select {
            width: 100%; /* Make select full width on small screens */
            max-width: 200px; /* Limit width on larger screens */
        }
        /* Ensure select doesn't get too narrow on small screens */
        @media (max-width: 639px) {
            .input-group select, .input-group input {
                width: calc(100% - 2rem); /* Account for padding */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-2xl font-bold mb-6">Silent Camera App</h1>

        <!-- The video feed is hidden by default -->
        <video id="cameraFeed" autoplay muted playsinline class="bg-black hidden"></video>
        <canvas id="photoCanvas" class="hidden bg-black"></canvas>

        <div class="message" id="message"></div>

        <div class="input-group mt-4">
            <label for="cameraSelect">Select Camera:</label>
            <select id="cameraSelect">
                <!-- Options will be dynamically populated here -->
            </select>
        </div>

        <div class="button-group">
            <button id="startCameraButton">Start Camera</button>
            <button id="takePhotoButton" disabled>Take Photo</button>
            <button id="recordVideoButton" disabled>Record Video</button>
            <button id="stopRecordingButton" disabled>Stop Recording</button>
        </div>

        <div class="input-group mt-4">
            <label for="photoInterval">Auto Photo Interval (seconds):</label>
            <input type="number" id="photoInterval" value="5" min="1">
        </div>
        <div class="button-group">
            <button id="startAutoPhotoButton" disabled>Start Automatic Photos</button>
            <button id="stopAutoPhotoButton" disabled>Stop Automatic Photos</button>
        </div>

        <div class="download-links" id="downloadLinks">
            <!-- Download links will be appended here -->
        </div>

        <div class="message mt-4 text-sm text-gray-400">
            *Note: Automatic photo capture works best when the browser tab is active and in focus. Browsers typically pause camera access for inactive tabs for privacy and resource management.
        </div>
    </div>

    <script>
        // Get references to DOM elements
        const cameraFeed = document.getElementById('cameraFeed');
        const photoCanvas = document.getElementById('photoCanvas');
        const messageElement = document.getElementById('message');
        const startCameraButton = document.getElementById('startCameraButton');
        const takePhotoButton = document.getElementById('takePhotoButton');
        const recordVideoButton = document.getElementById('recordVideoButton');
        const stopRecordingButton = document.getElementById('stopRecordingButton');
        const startAutoPhotoButton = document.getElementById('startAutoPhotoButton');
        const stopAutoPhotoButton = document.getElementById('stopAutoPhotoButton');
        const photoIntervalInput = document.getElementById('photoInterval');
        const downloadLinksDiv = document.getElementById('downloadLinks');
        const cameraSelect = document.getElementById('cameraSelect');

        let mediaStream = null; // Stores the camera stream
        let mediaRecorder = null; // Stores the MediaRecorder instance for video
        let recordedChunks = []; // Stores chunks of recorded video data
        let autoPhotoIntervalId = null; // Stores the interval ID for automatic photos
        let availableCameras = []; // Stores details of available video input devices

        // Function to display messages to the user
        function showMessage(msg, type = 'info') {
            messageElement.textContent = msg;
            messageElement.className = `message ${type === 'error' ? 'text-red-500' : 'text-yellow-500'}`;
        }

        // Function to enable/disable buttons based on camera and recording state
        function updateButtonStates(cameraActive, recording, autoCapturing) {
            startCameraButton.disabled = cameraActive;
            takePhotoButton.disabled = !cameraActive || recording || autoCapturing;
            recordVideoButton.disabled = !cameraActive || recording || autoCapturing;
            stopRecordingButton.disabled = !recording;
            startAutoPhotoButton.disabled = !cameraActive || recording || autoCapturing;
            stopAutoPhotoButton.disabled = !autoCapturing;
            photoIntervalInput.disabled = autoCapturing;
            cameraSelect.disabled = cameraActive; // Disable camera selection once started
        }

        // Function to populate the camera selection dropdown
        async function populateCameraSelect() {
            cameraSelect.innerHTML = ''; // Clear existing options
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');

                if (availableCameras.length === 0) {
                    showMessage('No video input devices found.', 'error');
                    startCameraButton.disabled = true; // Disable start button if no cameras
                    return;
                }

                // Add default options first
                // These are useful if device labels are not immediately available
                // or if specific facing modes are preferred.
                cameraSelect.add(new Option('Default Camera', 'default'));
                cameraSelect.add(new Option('Front Camera (User)', 'user'));
                cameraSelect.add(new Option('Back Camera (Environment)', 'environment'));

                // Add specific camera devices if labels are available
                availableCameras.forEach(device => {
                    const optionText = device.label || `Camera ${device.deviceId.substring(0, 8)}...`;
                    const option = new Option(optionText, device.deviceId);
                    cameraSelect.add(option);
                });

                showMessage('Cameras loaded. Select a camera and click "Start Camera".');

            } catch (err) {
                console.error('Error enumerating devices:', err);
                showMessage('Error enumerating cameras. Please ensure permissions are granted.', 'error');
                startCameraButton.disabled = true;
            }
        }

        // Function to start the camera feed
        async function startCamera() {
            // Check if camera is already active
            if (mediaStream && mediaStream.active) {
                showMessage('Camera is already running. Please stop it first to change camera.', 'info');
                return;
            }

            const selectedCameraId = cameraSelect.value;
            let videoConstraints = {};

            // Determine video constraints based on selection
            if (selectedCameraId === 'user') {
                videoConstraints = { facingMode: 'user' };
            } else if (selectedCameraId === 'environment') {
                videoConstraints = { facingMode: 'environment' };
            } else if (selectedCameraId === 'default') {
                // No specific facingMode, let browser pick default
                videoConstraints = true;
            } else {
                // Specific device ID selected
                videoConstraints = { deviceId: { exact: selectedCameraId } };
            }

            showMessage('Requesting camera access...');
            try {
                // Request video stream, explicitly no audio for silent operation
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: videoConstraints,
                    audio: false // Crucial for no sound
                });

                // Set the video element's source to the camera stream
                cameraFeed.srcObject = mediaStream;
                // Even though the video element is hidden, it needs to play
                // for its frames to be accessible by the canvas for photo capture
                // and by MediaRecorder for video recording.
                await cameraFeed.play();

                showMessage(`Camera (${selectedCameraId}) started successfully. You can now take photos, record videos, or start automatic photo capture.`);
                updateButtonStates(true, false, false); // Camera active, not recording, not auto-capturing

            } catch (err) {
                console.error('Error accessing camera:', err);
                if (err.name === 'NotAllowedError') {
                    showMessage('Camera access denied. Please allow camera permissions in your browser settings.', 'error');
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    showMessage('No camera found on your device or the selected camera is not available.', 'error');
                } else if (err.name === 'OverconstrainedError') {
                    showMessage(`The selected camera or facing mode is not available. Try another option.`, 'error');
                }
                else {
                    showMessage(`Error: ${err.message || 'Could not start camera.'}`, 'error');
                }
                updateButtonStates(false, false, false); // Camera inactive
            }
        }

        // Function to stop the camera feed
        function stopCamera() {
            if (mediaStream) {
                // Stop any ongoing automatic photo capture
                stopAutomaticPhotos();
                // Stop all tracks in the stream
                mediaStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null; // Clear the video element source
                mediaStream = null; // Clear the stream variable
                showMessage('Camera stopped.');
                updateButtonStates(false, false, false); // Camera inactive
                // Clear any existing download links
                downloadLinksDiv.innerHTML = '';
            }
        }

        // Function to capture a single photo
        function capturePhoto() {
            if (!mediaStream || !mediaStream.active) {
                showMessage('Camera is not active. Cannot capture photo.', 'error');
                return;
            }

            // Set canvas dimensions to match video stream dimensions
            photoCanvas.width = cameraFeed.videoWidth;
            photoCanvas.height = cameraFeed.videoHeight;

            const context = photoCanvas.getContext('2d');
            // Draw the current frame of the video onto the canvas
            context.drawImage(cameraFeed, 0, 0, photoCanvas.width, photoCanvas.height);

            // Get image data as a PNG data URL
            const imageDataUrl = photoCanvas.toDataURL('image/png');

            // Create a download link for the photo
            const downloadLink = document.createElement('a');
            downloadLink.href = imageDataUrl;
            downloadLink.download = `auto-photo-${new Date().toISOString()}.png`;
            downloadLink.textContent = `Download Photo (${new Date().toLocaleTimeString()})`;
            downloadLink.classList.add('text-sm'); // Make text a bit smaller for multiple links
            downloadLinksDiv.prepend(downloadLink); // Add to the top of download links

            showMessage('Photo captured!');
        }

        // Event listener for the "Take Photo" button
        takePhotoButton.addEventListener('click', capturePhoto);

        // Function to start video recording
        recordVideoButton.addEventListener('click', () => {
            if (!mediaStream || !mediaStream.active) {
                showMessage('Camera is not active. Please start the camera first.', 'error');
                return;
            }

            // Stop any ongoing automatic photo capture before recording
            stopAutomaticPhotos();

            // Clear previous recorded chunks
            recordedChunks = [];
            // Create a new MediaRecorder instance from the media stream
            mediaRecorder = new MediaRecorder(mediaStream);

            // Event listener for when data is available (video chunks)
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            // Event listener for when recording stops
            mediaRecorder.onstop = () => {
                // Create a Blob from all recorded chunks
                const blob = new Blob(recordedChunks, { type: 'video/webm' }); // WebM is widely supported
                const videoUrl = URL.createObjectURL(blob); // Create a URL for the Blob

                // Create a download link for the video
                const downloadLink = document.createElement('a');
                downloadLink.href = videoUrl;
                downloadLink.download = `video-${new Date().toISOString()}.webm`;
                downloadLink.textContent = 'Download Video';
                downloadLinksDiv.prepend(downloadLink); // Add to the top of download links

                showMessage('Video recording stopped.');
            };

            // Start recording
            mediaRecorder.start();
            showMessage('Recording video...');
            updateButtonStates(true, true, false); // Camera active, recording in progress
        });

        // Function to stop video recording
        stopRecordingButton.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                updateButtonStates(true, false, false); // Camera active, not recording, not auto-capturing
            } else {
                showMessage('No video recording in progress.', 'error');
            }
        });

        // Function to start automatic photo capture
        startAutoPhotoButton.addEventListener('click', () => {
            if (!mediaStream || !mediaStream.active) {
                showMessage('Camera is not active. Please start the camera first.', 'error');
                return;
            }

            const intervalSeconds = parseInt(photoIntervalInput.value, 10);
            if (isNaN(intervalSeconds) || intervalSeconds < 1) {
                showMessage('Please enter a valid interval (1 second or more).', 'error');
                return;
            }

            // Stop any existing auto-capture first
            stopAutomaticPhotos();

            // Start automatic capture
            autoPhotoIntervalId = setInterval(capturePhoto, intervalSeconds * 1000); // Convert seconds to milliseconds
            showMessage(`Automatic photo capture started every ${intervalSeconds} seconds.`);
            updateButtonStates(true, false, true); // Camera active, not recording, auto-capturing
        });

        // Function to stop automatic photo capture
        stopAutoPhotoButton.addEventListener('click', () => {
            stopAutomaticPhotos();
        });

        function stopAutomaticPhotos() {
            if (autoPhotoIntervalId) {
                clearInterval(autoPhotoIntervalId);
                autoPhotoIntervalId = null;
                showMessage('Automatic photo capture stopped.');
                updateButtonStates(true, false, false); // Camera active, not recording, not auto-capturing
            }
        }

        // Event listener for the "Start Camera" button
        startCameraButton.addEventListener('click', startCamera);

        // Optional: Stop camera and auto-capture when the user navigates away or closes the tab
        window.addEventListener('beforeunload', stopCamera);

        // Initial setup on page load
        populateCameraSelect(); // Populate camera dropdown first
        updateButtonStates(false, false, false);
        showMessage('Select a camera and click "Start Camera".');
    </script>
</body>
</html>
